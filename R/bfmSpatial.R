
#' @title Function to run bfastmonitor on any kind of raster brick, with parallel support
#' 
#' @description Implements bfastmonitor function, from the bfast package on any kind of rasterBrick object. Time information is provided as an extra object and the time series can be regular or irregular.
#' 
#' @param x rasterBrick or rasterStack object, or file name to a multilayer raster object stored on disk.
#' @param dates A date vector. The number of dates must match the number of layers of x.
#' @param pptype Character. Type of preprocessing to be applied to individual time series vectors. The two options are 'irregular' and '16-days'. See bfastts for more details.
#' @param start See \code{\link{bfastmonitor}}
#' @param monend Numeric. End of the monitoring period in the format c(year, julian day). All raster data after this time will be removed before running \code{bfastmonitor}
#' @param sensor Character. Limit analysis to a particular sensor. Defaults to "all". See \link{\code{subsetRasterTS}} for more information on allowed values.
#' @param formula See \code{\link{bfastmonitor}}
#' @param order See \code{\link{bfastmonitor}}
#' @param lag See \code{\link{bfastmonitor}}
#' @param slag See \code{\link{bfastmonitor}}
#' @param history See \code{\link{bfastmonitor}}
#' @param type See \code{\link{bfastmonitor}}
#' @param n See \code{\link{bfastmonitor}}
#' @param level See \code{\link{bfastmonitor}}
#' @param mc.cores Numeric. Number of cores to be used for the job.
#' @param ... Arguments to be passed to \code{\link{mc.calc}}
#' @return A rasterBrick, with 3 layers. (1) Breakpoints (time of change); (2) change magnitude; and (3) error flag (1, NA). See \code{\link{bfastmonitor}}
#' @author Loic Dutrieux
#' @import bfast
#' @import parallel
#' @import raster
#' 
#' @examples
#' # load tura dataset
#' data(tura)
#' 
#' # run BFM over entire time series with a monitoring period of c(2009, 1)
#' t1 <- system.time(bfm <- bfmSpatial(tura, start=c(2005, 1)))
#' plot(t1)
#' 
#' # with multi-core support
#' t2 <- system.time(bfm <- bfmSpatial(tura, start=c(2005, 1), mc.cores=2))
#' t1 - t2
#' @export
#' 
#' 


# Author: Loic Dutrieux
# January 2014

bfmSpatial <- function(x, dates=NULL, pptype='irregular', start, monend=NULL, sensor="all",
                       formula = response ~ trend + harmon, order = 3, lag = NULL, slag = NULL,
                       history = c("ROC", "BP", "all"),
                       type = "OLS-MOSUM", h = 0.25, end = 10, level = 0.05, mc.cores=1, ...) {
    
    if(is.character(x)) {
        x <- brick(x)
    }
    
    if(is.null(dates)) {
        if(is.null(getZ(x))) {
            if(!all(grepl(pattern='(LT4|LT5|LE7)\\d{13}', x=names(x)))){ # Check if dates can be extracted from layernames
                stop('A date vector must be supplied, either via the date argument, the z dimention of x or comprised in names(x)')
            } else {
                dates <- as.Date(getSceneinfo(names(x))$date)
            }
        } else {
            dates <- getZ(x)
        }
    }
    
    # check that monend < max(dates) (and ignore if not)
    if(!is.null(monend) & as.Date(paste(monend, collapse="-"), format="%Y-%j") >= max(dates))
        monend <-  NULL
    
    # subset rasterTS if sensor or monend are supplied
    if(sensor != "all" | !is.null(monend)){
        x <- subsetRasterTS(x, sensor=sensor, maxDate=monend)
    }

    fun <- function(x) {
        ts <- bfastts(x, dates=dates, type=pptype)
        bfm <- try(bfastmonitor(data=ts, start=start,
                                formula=formula,
                                order=order, lag=lag, slag=slag,
                                history=history,
                                type=type, h=h,
                                end=end, level=level), silent=TRUE)
        if(class(bfm) == 'try-error') {
            res <- cbind(NA, NA, 1)
        } else {
            res <- cbind(bfm$breakpoint, bfm$magnitude, NA)
        }
        names(res) <- c("breakpoint", "magnitude", "error")
        return(res)
    }
    
    out <- mc.calc(x=x, fun=fun, mc.cores=mc.cores, ...)
    return(out)
    
}